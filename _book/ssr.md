## ssr

> 服务端渲染：服务端渲染出完整的首屏的 dom 结构返回，前端拿到内容包括首屏及完整的spa结构，应用激活后依然按照spa方式运行。

#### 作用
* 解决单页面应用的 SEO 问题
	* 不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本，使用MVVM框架后，页面大多数 DOM 元素都是在客户端根据 js 动态生成
* 更利于首屏渲染
	* 单页面打包文件体积大，使得普通客户端渲染加载所需文件的时间较长，首页就会有一个很长的白屏等待时间，使用 ssr 渲染，使得渲染并不依赖于 js 文件，而是直接渲染服务端发送过来的 html 字符串。
* 后端生成静态化文件

#### 缺点
* 服务端压力较大
	* 再遇到高并发访问的情况，会大量占用服务端CPU资源
		* 需要对渲染进行缓存优化 
* 项目的搭建、部署过程更加复杂
* 一些单页面应用的生命周期钩子不能使用
	* 项目中用到的一些第三方库，这些库对应的生命周期钩子也将不能使用，这对我们引用库的选择产生了很大的限制

#### 应用场景
* 有 SEO 诉求，用在搜索引擎检索以及社交分享，在前台类应用使用场景较多，对于中后台应用而言这些就不是必需品。
* 在移动端、弱网情况下、首屏渲染的时长就会显得非常重要

#### 拓展
> 预渲染

* 预渲染与服务端渲染唯一的不同点在于渲染时机，服务端渲染的时机是在用户访问时执行渲染（即实时渲染，数据一般是最新的），预渲染的时机是在项目构建时，当用户访问时，数据不是一定是最新的（如果数据没有实时性，则可以直接考虑预渲染）。
* 预渲染（Pre Render）在构建时执行渲染，将渲染后的 HTML 片段生成静态 HTML 文件。无需使用 web 服务器实时动态编译 HTML，适用于静态站点生成


## csr

* code spliting 首屏优化


#### 实战
* 安装 vue-server-renderer、koa
	
	* 创建 koa 实例
	* 创建渲染器 createRenderer
	* 路由

	```
	app.get('/', (ctx) => {
		
		// 构建渲染页面内容
		
		// 渲染
		
		// 发送
	})
	```
	* 监听端口

* 问题：交互、路由目前由koa管理、同构开发

	* 路由
		* 服务端 
			* 工厂函数，每次请求返回一个全新的Router实例，避免全局污染
			* 每次请求返回一个Vue实例
			* 服务端没有dom所以不进行挂载
			* 创建一个 vue 实例，return 一个 promise，此处服务端可能会有一些异步请求，故而返回 promise，然后 router 接管路由，此处路由也可能是异步的，所以需要等待就绪然后进行操作（router.onReady）
		* 客户端
			* 激活
			
			```
			createApp()
			
			route.onready 之后进行vue $mount
			
			```
			
		* webpack 打包 server、client
		* cross-env 安装依赖、.env
		* 宿主文件
			* 删除之前动态标签
			* 将宿主元素变为一个注释 <!--vue-ssr-outlet-->


			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			